<!DOCTYPE html>
<html>
<head>
  <title>Hummble VS</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #outputContainer {
      display: flex;
      align-items: flex-start;
      width: 100%;
      justify-content: center;
    }
    #output {
      border: 1px solid #ccc;
      padding: 10px;
      margin-top: 10px;
      width: 50%;
      height: 70vh;
      overflow-y: scroll;
    }
    .button-group {
      position: absolute;
      right: 40px;
      top: 250px; /* Adjust this value to position the buttons */
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
      align-items: center;
    }
    .controls div {
      display: flex;
      gap: 10px;
    }
    #inputSection {
      display: flex;
      gap: 10px;
      width: 68%;
    }
    #input {
      flex-grow: 1;
    }
    button {
      padding: 10px;
      width: 150px; /* Set a fixed width for all buttons */
    }
    .logo-container {
      position: absolute;
      right: 40px;
      top: 40px; /* Adjust this value to position the logo */
    }
    .logo {
      max-width: 250px; /* Adjust size as necessary */
    }
    #statusIndicator {
      width: 150px; /* Same width as the buttons */
      padding: 10px;
      border: 1px solid #ccc;
      text-align: center;
      margin-bottom: 10px;
      background-color: #f0f0f0;
      position: absolute;
      right: 40px;
      top: 200px; /* Adjust to position the status indicator */
    }
  </style>
</head>
<body>
  <h1>Hummble Control Interface</h1>
  <div class="controls">
    <div>
      <button id="connect">Connect to Hummble</button>
      <button id="clearOutput">Clear Output</button>
    </div>
    <div id="inputSection">
      <input type="text" id="input" placeholder="Command   ">
      <button id="send">Send</button>
    </div>
  </div>
  <div id="outputContainer">
    <div id="output"></div>
  </div>
  <div class="logo-container">
    <img src="https://github.com/GergoOrosz/HummbleUI/blob/main/Screenshot%202024-07-22%20at%2023.23.00.png?raw=true" alt="Logo" class="logo"> <!-- Add your logo image here -->
  </div>
  <div id="statusIndicator">Status: Not Connected</div>
  <div class="button-group">
    <button id="setup">Setup</button>
    <button id="continue">Continue</button>
    <button id="save">Save</button>
    <button id="reset">Factory Reset</button>
    <button id="monitor">Monitor</button>
    <button id="toggle">Toggle ANC</button>
    <button id="reboot">Reboot</button>
  </div>

  <script>
    let port;
    let reader;
    let outputStream;
    let messageBuffer = '';
    let monitoring = true;
    let isBusy = false;
    let isConnected = false;

    const connectButton = document.getElementById('connect');
    const sendButton = document.getElementById('send');
    const setupButton = document.getElementById('setup');
    const continueButton = document.getElementById('continue');
    const saveButton = document.getElementById('save');
    const resetButton = document.getElementById('reset');
    const monitorButton = document.getElementById('monitor');
    const toggleButton = document.getElementById('toggle');
    const rebootButton = document.getElementById('reboot');
    const clearOutputButton = document.getElementById('clearOutput');
    const outputDiv = document.getElementById('output');
    const inputField = document.getElementById('input');
    const statusIndicator = document.getElementById('statusIndicator');

    connectButton.addEventListener('click', async () => {
      if (!("serial" in navigator)) {
        outputDiv.innerHTML += 'WebSerial is not supported in this browser.<br>';
        return;
      }

      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        outputDiv.innerHTML += 'Connected to Hummble<br>';
        statusIndicator.textContent = 'Status: Connected';
        isConnected = true;

        outputStream = port.writable.getWriter();
        reader = port.readable.getReader();
        readLoop();
        startStatusUpdates(); // Start requesting status updates
      } catch (error) {
        outputDiv.innerHTML += 'Error: ' + error + '<br>';
        console.error('Connect Error:', error);
        statusIndicator.textContent = 'Status: Not Connected';
        isConnected = false;
      }
    });

    sendButton.addEventListener('click', () => sendMessage(inputField.value + '\n'));

    inputField.addEventListener('keypress', event => {
      if (event.key === 'Enter') {
        sendMessage(inputField.value + '\n');
      }
    });

    const commandButtons = [
      { button: setupButton, command: '<setup>\n' },
      { button: continueButton, command: '<continue>\n' },
      { button: saveButton, command: '<save:1>\n' },
      { button: resetButton, command: '<save:0>\n' },
      { button: monitorButton, command: () => (monitoring ? '<mt:3>\n' : '<mt:0>\n'), toggle: true },
      { button: toggleButton, command: '<toggle>\n' },
      { button: rebootButton, command: '<boot>\n' }
    ];

    commandButtons.forEach(({ button, command, toggle }) => {
      button.addEventListener('click', async () => {
        sendMessage(typeof command === 'function' ? command() : command);
        if (toggle) monitoring = !monitoring;
      });
    });

    clearOutputButton.addEventListener('click', () => {
      outputDiv.innerHTML = '';
    });

    async function sendMessage(message) {
      if (!isConnected) {
        outputDiv.innerHTML += 'Error: No device connected<br>';
        return;
      }
      isBusy = true;
      const encoder = new TextEncoder();
      const data = encoder.encode(message);
      await outputStream.write(data);
      inputField.value = '';
      isBusy = false;
    }

    function escapeHtml(unsafe) {
      return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    async function readLoop() {
      const decoder = new TextDecoder();
      while (true) {
        try {
          const { value, done } = await reader.read();
          if (done) {
            reader.releaseLock();
            break;
          }
          const chunk = decoder.decode(value);
          messageBuffer += chunk;

          let endOfMessageIndex;
          while ((endOfMessageIndex = messageBuffer.indexOf('\n')) !== -1) {
            const message = messageBuffer.slice(0, endOfMessageIndex + 1);
            messageBuffer = messageBuffer.slice(endOfMessageIndex + 1);
            processMessage(message);
          }
        } catch (error) {
          console.error('Read Error:', error);
          break;
        }
      }
    }

    function processMessage(message) {
      const escapedMessage = escapeHtml(message);
      if (escapedMessage.startsWith('%') && escapedMessage.endsWith('%')) {
        const status = escapedMessage.slice(0, -1);
        if (status === 'STATUS0') {
          statusIndicator.textContent = 'Status: Idle';
        } else if (status === 'STATUS1') {
          statusIndicator.textContent = 'Status: Calibration';
        }
      } else {
        outputDiv.innerHTML += escapedMessage + '<br>';
        outputDiv.scrollTop = outputDiv.scrollHeight;
      }
    }

    function startStatusUpdates() {
      setInterval(async () => {
        if (!isBusy && isConnected) {
          isBusy = true;
          const encoder = new TextEncoder();
          const data = encoder.encode('<status>\n');
          await outputStream.write(data);
          isBusy = false;
        }
      }, 1000);
    }
  </script>
</body>
</html>
